<script>
// --- Data ---
let players = []; 
let courts = [];  
let courtCount = 2;
let bookingCounter = 0;
let activeGameResolveCourtId = null;
let pairingHistory = {}; 
let matchLogs = [];

// --- Configuration (Frozen Logic V4.0) ---
const AVG_GAME_DURATION = 15; 
const AUTO_START_DELAY = 10; 

// --- Init ---
function init() {
    renderCourts();
    updateQueueDisplay();
    setInterval(autoFillCourts, 1000);
    updateCustomHoursInputs(); // Init cost calc inputs
}

// --- VIEW SWITCHING ---
function toggleView(viewName) {
    document.getElementById('main-view').classList.add('hidden');
    document.getElementById('overview-view').classList.add('hidden');
    
    if(viewName === 'main') {
        document.getElementById('main-view').classList.remove('hidden');
    } else {
        document.getElementById('overview-view').classList.remove('hidden');
        renderOverview();
    }
}

// --- LOGIC: MATCHMAKING ---
function getPairKey(id1, id2) { return id1 < id2 ? `${id1}-${id2}` : `${id2}-${id1}`; }
function recordPairing(id1, id2) {
    const key = getPairKey(id1, id2);
    if (!pairingHistory[key]) pairingHistory[key] = 0;
    pairingHistory[key]++;
}
function getPairCount(id1, id2) { return pairingHistory[getPairKey(id1, id2)] || 0; }

function addPlayers() {
    const input = document.getElementById('new-players');
    const rawText = input.value.trim();
    if (!rawText) return;
    const names = rawText.split('\n').map(n => n.trim()).filter(n => n);
    let maxGamesInSystem = 0;
    players.forEach(p => { if(p.gamesPlayed > maxGamesInSystem) maxGamesInSystem = p.gamesPlayed; });

    names.forEach(name => {
        let cleanName = name.replace(/^[\d]+\.[\s]*/, '');
        let joinTime = Date.now();
        let isFastPass = false;
        if (maxGamesInSystem > 2) {
            joinTime = Date.now() - (60 * 60 * 1000); 
            isFastPass = true;
        }
        players.push({
            id: Date.now() + Math.random(),
            name: cleanName,
            gamesPlayed: 0,
            wins: 0,
            status: 'waiting',
            joinedQueueAt: joinTime, 
            bookingId: null,
            sessionGames: 0,
            isFastPass: isFastPass,
            checkInTime: new Date()
        });
    });
    input.value = '';
    updateQueueDisplay();
}

function removePlayer(id) {
    if(!confirm('‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏•‡∏ö‡∏ä‡∏∑‡πà‡∏≠‡∏ô‡∏µ‡πâ?')) return;
    const p = players.find(x => x.id === id);
    if(p && p.status === 'playing') { alert('‡πÄ‡∏•‡πà‡∏ô‡∏≠‡∏¢‡∏π‡πà ‡∏•‡∏ö‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ'); return; }
    players = players.filter(p => p.id !== id);
    updateQueueDisplay();
}

function resetStatsOnly() {
    if(!confirm('‡∏£‡∏µ‡πÄ‡∏ã‡πá‡∏ï‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥?')) return;
    players.forEach(p => { 
        p.gamesPlayed = 0; p.wins = 0; p.sessionGames = 0; 
        p.status = 'waiting'; p.joinedQueueAt = Date.now(); p.bookingId = null; p.isFastPass = false;
    });
    pairingHistory = {};
    matchLogs = [];
    renderMatchLog();
    resetCourtsState();
    updateQueueDisplay();
}

function resetAll() {
    if(!confirm('‡∏•‡πâ‡∏≤‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î?')) return;
    players = [];
    pairingHistory = {};
    matchLogs = [];
    renderMatchLog();
    resetCourtsState();
    updateQueueDisplay();
}

function resetCourtsState() {
    courts.forEach(c => {
        clearInterval(c.interval);
        c.players = []; c.state = 'empty'; c.timer = 0; c.isOpened = false; c.autoStartTarget = null;
    });
    renderCourts();
}

function updateCourts(change) {
    const newCount = courtCount + change;
    if (newCount < 1) return;
    courtCount = newCount;
    document.getElementById('court-count').innerText = courtCount;
    document.getElementById('calc-court-count').value = courtCount;
    updateCustomHoursInputs();
    renderCourts();
}

function renderCourts() {
    const container = document.getElementById('courts-container');
    if (courts.length < courtCount) {
        for (let i = courts.length; i < courtCount; i++) {
            courts.push({ id: i, players: [], state: 'empty', timer: 0, interval: null, isOpened: false, autoStartTarget: null });
        }
    } else if (courts.length > courtCount) {
        const removed = courts.pop();
            if (removed.players.length > 0) {
            removed.players.forEach(p => {
                const pl = players.find(x => x.id === p.id);
                if(pl) { pl.status = 'waiting'; pl.joinedQueueAt = Date.now(); pl.sessionGames = 0; }
            });
        }
    }
    container.innerHTML = '';
    courts.forEach((court, index) => {
        let overlayHTML = '';
        if (court.state === 'post_game') {
            overlayHTML = `
                <div class="court-overlay">
                    <button class="btn-overlay btn-call" onclick="triggerFill(${index})">üì¢ ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏Ñ‡∏ô‡∏•‡∏á</button>
                    <button class="btn-overlay btn-rest" onclick="closeAndRest(${index})">üî¥ ‡∏û‡∏±‡∏Å‡∏Ñ‡∏≠‡∏£‡πå‡∏ó</button>
                </div>
            `;
        } else if (!court.isOpened) {
            overlayHTML = `
                <div class="court-overlay">
                    <button class="btn-overlay btn-open" onclick="openCourt(${index})">üîî ‡πÄ‡∏õ‡∏¥‡∏î‡∏™‡∏ô‡∏≤‡∏°</button>
                </div>
            `;
        }
        const courtHTML = `
            <div class="court" id="court-${index}">
                <div class="court-lines"></div>
                <div class="service-line-top"></div>
                <div class="service-line-bottom"></div>
                <div class="court-header"><span>#${index + 1}</span><small>${getRuleLabel()}</small></div>
                ${overlayHTML}
                <div class="court-players">
                    <div class="team team-pink">${renderPlayerOnCourt(court.players[0], index, 0)}${renderPlayerOnCourt(court.players[1], index, 1)}</div>
                    <div class="team team-blue">${renderPlayerOnCourt(court.players[2], index, 2)}${renderPlayerOnCourt(court.players[3], index, 3)}</div>
                </div>
                <div class="court-controls">
                    <div class="timer" id="timer-${index}">${formatTime(court.timer)}</div>
                    ${renderCourtButtons(court, index)}
                </div>
            </div>
        `;
        container.innerHTML += courtHTML;
    });
    updateQueueDisplay();
    updateDashboard(); 
}

function openCourt(idx) { courts[idx].isOpened = true; renderCourts(); }
function triggerFill(idx) { courts[idx].state = 'empty'; renderCourts(); }
function closeAndRest(idx) {
    courts[idx].players.forEach(p => sendToQueue(p.id));
    courts[idx].players = []; courts[idx].state = 'empty'; courts[idx].isOpened = false; courts[idx].timer = 0;
    renderCourts();
}
function getRuleLabel() { return document.getElementById('game-rule').value === 'winner_stay' ? "Fixed Quota" : ""; }
function renderPlayerOnCourt(player, courtIdx, slotIdx) {
    if (!player) return '<div class="player-on-court" style="opacity:0.5; background:#eee; color:#aaa; border:none;">‡∏ß‡πà‡∏≤‡∏á</div>';
    const rule = document.getElementById('game-rule').value;
    let badge = (rule === 'winner_stay') ? `<span class="quota-badge" style="background:${player.sessionGames >= 1 ? '#e67e22' : '#27ae60'}">G: ${player.sessionGames + 1}/2</span>` : '';
    return `<div class="player-on-court" title="‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏±‡∏ß" onclick="kickPlayer(${courtIdx}, ${slotIdx})"><strong>${player.name}</strong><span style="font-size:0.8em; margin-top:2px;">(${player.gamesPlayed}P)</span>${badge}</div>`;
}
function renderCourtButtons(court, idx) {
    if (!court.isOpened || court.state === 'post_game') return `<button class="secondary" style="width:100%;" disabled>...</button>`;
    if (court.state === 'playing') return `<button class="danger" style="width:100%;" onclick="stopGame(${idx})">‡∏à‡∏ö‡πÄ‡∏Å‡∏°</button>`;
    else if (court.players.length === 4) {
        if (court.autoStartTarget) {
            const remaining = Math.ceil((court.autoStartTarget - Date.now()) / 1000);
            if (remaining > 0) return `<button class="success btn-auto-start" style="width:100%;" onclick="startGame(${idx})">‡πÄ‡∏£‡∏¥‡πà‡∏° (Auto ${remaining}s)</button>`;
        }
        return `<button class="success" style="width:100%;" onclick="startGame(${idx})">‡πÄ‡∏£‡∏¥‡πà‡∏°‡πÄ‡∏Å‡∏°</button>`;
    } else return `<button class="secondary" style="width:100%;" disabled>‡∏£‡∏≠‡∏Ñ‡∏ô...</button>`;
}

// --- üß† SMART AUTO FILL (V5.1 Wave's Logic) ---
function autoFillCourts() {
    courts.forEach((court, idx) => {
        if (!court.isOpened || court.state === 'playing' || court.state === 'post_game') return;

        if (court.players.length < 4) {
            court.autoStartTarget = null;
            const needed = 4 - court.players.length;
            
            let candidates = getSmartDraft(needed);
            
            if (candidates.length > 0) {
                candidates.forEach(p => {
                    p.status = 'playing';
                    p.sessionGames = 0;
                    if(p.isFastPass) p.isFastPass = false;
                    court.players.push(p);
                });
                renderCourts();
            }
        }

        if (court.players.length === 4) {
            if (!court.autoStartTarget) { 
                court.autoStartTarget = Date.now() + (AUTO_START_DELAY * 1000); 
                renderCourts(); 
            }
            else if (Date.now() >= court.autoStartTarget) { 
                startGame(idx); 
            }
            else {
                const btn = document.querySelector(`#court-${idx} .btn-auto-start`);
                if (btn) btn.innerHTML = `‡πÄ‡∏£‡∏¥‡πà‡∏° (Auto ${Math.ceil((court.autoStartTarget - Date.now()) / 1000)}s)`;
            }
        }
    });
}

function getSmartDraft(count) {
    let pool = players.filter(p => p.status === 'waiting');
    pool.sort((a, b) => a.joinedQueueAt - b.joinedQueueAt); 

    if (pool.length === 0) return [];

    if (pool[0].bookingId) {
        const bId = pool[0].bookingId;
        const group = pool.filter(p => p.bookingId === bId);
        if (group.length <= count) return group;
    }

    let selected = [];
    let usedIds = new Set();
    
    let captain = pool[0];
    selected.push(captain);
    usedIds.add(captain.id);

    while (selected.length < count && selected.length < pool.length) {
        let nextPlayer = null;

        if (selected.length % 2 !== 0) {
            let currentSolo = selected[selected.length - 1];
            nextPlayer = findBestPartnerInfinite(currentSolo, pool, usedIds);
        } else {
            nextPlayer = pool.find(p => !usedIds.has(p.id) && !p.bookingId); 
        }

        if (nextPlayer) {
            selected.push(nextPlayer);
            usedIds.add(nextPlayer.id);
        } else {
            let fallback = pool.find(p => !usedIds.has(p.id));
            if (fallback) { selected.push(fallback); usedIds.add(fallback.id); }
            else break;
        }
    }
    return selected;
}

function findBestPartnerInfinite(captain, fullPool, usedIds) {
    let best = null; 
    let minScore = Infinity;
    
    for (let i = 0; i < fullPool.length; i++) {
        const c = fullPool[i];
        
        if (c.id === captain.id || usedIds.has(c.id) || c.bookingId) continue; 
        
        const count = getPairCount(captain.id, c.id);
        const penalty = (count >= 2) ? 999999999 : count * 1000000;
        const score = penalty + i; 
        
        if (score < minScore) { 
            minScore = score; 
            best = c; 
        }
    }
    return best;
}

function startGame(courtIdx) {
    const court = courts[courtIdx]; court.state = 'playing'; court.timer = 0; court.autoStartTarget = null; 
    if(court.players[0] && court.players[1]) recordPairing(court.players[0].id, court.players[1].id);
    if(court.players[2] && court.players[3]) recordPairing(court.players[2].id, court.players[3].id);
    court.interval = setInterval(() => { court.timer++; document.getElementById(`timer-${courtIdx}`).innerText = formatTime(court.timer); }, 1000);
    renderCourts();
}

function stopGame(courtIdx) {
    const court = courts[courtIdx]; clearInterval(court.interval);
    court.players.forEach(p => { const pl = players.find(x => x.id === p.id); if(pl) { pl.gamesPlayed++; pl.sessionGames++; } });
    activeGameResolveCourtId = courtIdx; document.getElementById('winner-modal').style.display = 'flex';
}

function cancelStopGame() {
    const court = courts[activeGameResolveCourtId];
    court.players.forEach(p => { const pl = players.find(x => x.id === p.id); if(pl) { pl.gamesPlayed--; pl.sessionGames--; } });
    court.interval = setInterval(() => { court.timer++; document.getElementById(`timer-${activeGameResolveCourtId}`).innerText = formatTime(court.timer); }, 1000);
    document.getElementById('winner-modal').style.display = 'none'; activeGameResolveCourtId = null; renderCourts();
}

function resolveGame(winningTeamIdx) { 
    const court = courts[activeGameResolveCourtId]; 
    document.getElementById('winner-modal').style.display = 'none';

    // ‡∏Å‡∏£‡∏ì‡∏µ 1: ‡∏¢‡∏Å‡πÄ‡∏•‡∏¥‡∏Å‡πÄ‡∏Å‡∏° (‡πÑ‡∏°‡πà‡∏°‡∏µ‡πÉ‡∏Ñ‡∏£‡∏ä‡∏ô‡∏∞/‡πÅ‡∏û‡πâ) -> ‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô‡πÄ‡∏î‡πâ‡∏á‡∏≠‡∏≠‡∏Å‡πÑ‡∏õ‡∏ï‡πà‡∏≠‡∏Ñ‡∏¥‡∏ß‡πÉ‡∏´‡∏°‡πà
    if (winningTeamIdx === -1) { 
        court.players.forEach(p => sendToQueue(p.id)); 
        court.players = []; 
        court.state = 'post_game'; 
    } 
    // ‡∏Å‡∏£‡∏ì‡∏µ 2: ‡∏°‡∏µ‡πÅ‡∏û‡πâ/‡∏ä‡∏ô‡∏∞
    else {
        const t1 = [court.players[0], court.players[1]]; 
        const t2 = [court.players[2], court.players[3]]; 
        
        let winners = (winningTeamIdx === 0) ? t1 : t2; 
        let losers = (winningTeamIdx === 0) ? t2 : t1;
        
        // ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å Log
        matchLogs.unshift({ 
            time: new Date().toLocaleTimeString('th-TH', {hour:'2-digit', minute:'2-digit'}), 
            court: activeGameResolveCourtId+1, 
            winners: winners.map(p=>p.name).join(', '), 
            losers: losers.map(p=>p.name).join(', '), 
            duration: formatTime(court.timer) 
        });
        renderMatchLog();
        
        // ‡∏ö‡∏ß‡∏Å‡∏™‡∏ñ‡∏¥‡∏ï‡∏¥‡∏ä‡∏ô‡∏∞
        winners.forEach(p => { 
            const pl = players.find(x => x.id === p.id); 
            if(pl) pl.wins++; 
        });

        let stayers = [], leavers = [];
        
        // --- üîç ‡∏à‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÅ‡∏Å‡πâ: ‡πÄ‡∏ä‡πá‡∏Ñ‡πÇ‡∏´‡∏°‡∏î‡πÄ‡∏Å‡∏°‡∏Å‡πà‡∏≠‡∏ô! ---
        const rule = document.getElementById('game-rule').value;

        if (rule === 'normal') {
            // ‡πÇ‡∏´‡∏°‡∏î Normal: ‡∏≠‡∏≠‡∏Å‡∏´‡∏°‡∏î‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô ‡πÑ‡∏°‡πà‡∏™‡∏ô‡∏•‡∏π‡∏Å‡πÉ‡∏Ñ‡∏£!
            leavers.push(...t1, ...t2);
        } else {
            // ‡πÇ‡∏´‡∏°‡∏î Fixed Quota (Winner Stay ‡πÅ‡∏ö‡∏ö‡∏°‡∏µ‡πÇ‡∏Ñ‡∏ß‡∏ï‡πâ‡∏≤ 2 ‡πÄ‡∏Å‡∏°)
            const q1 = players.find(x => x.id === t1[0].id).sessionGames; 
            const q2 = players.find(x => x.id === t2[0].id).sessionGames;

            if (q1 < 2 && q2 < 2) { 
                // ‡∏ñ‡πâ‡∏≤‡πÇ‡∏Ñ‡∏ß‡∏ï‡πâ‡∏≤‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÄ‡∏ï‡πá‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏Ñ‡∏π‡πà -> ‡∏ú‡∏π‡πâ‡∏ä‡∏ô‡∏∞‡∏≠‡∏¢‡∏π‡πà‡∏ï‡πà‡∏≠, ‡∏ú‡∏π‡πâ‡πÅ‡∏û‡πâ‡∏≠‡∏≠‡∏Å
                if (winningTeamIdx === 0) { stayers.push(...t1); leavers.push(...t2); } 
                else { stayers.push(...t2); leavers.push(...t1); } 
            } else { 
                // ‡∏ñ‡πâ‡∏≤‡∏°‡∏µ‡πÉ‡∏Ñ‡∏£‡πÇ‡∏Ñ‡∏ß‡∏ï‡πâ‡∏≤‡πÄ‡∏ï‡πá‡∏° (‡∏Ñ‡∏£‡∏ö 2 ‡πÄ‡∏Å‡∏°) -> ‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏≠‡∏Å
                if (q1 >= 2) leavers.push(...t1); else stayers.push(...t1); 
                if (q2 >= 2) leavers.push(...t2); else stayers.push(...t2); 
            }
        }
        
        // ‡∏™‡∏±‡πà‡∏á‡∏¢‡πâ‡∏≤‡∏¢‡∏Ñ‡∏ô
        leavers.forEach(p => sendToQueue(p.id)); 
        court.players = [...stayers]; 
        court.state = 'post_game';
    }
    court.timer = 0; 
    renderCourts();
}

function sendToQueue(playerId) { const pl = players.find(x => x.id === playerId); if(pl) { pl.status = 'waiting'; pl.joinedQueueAt = Date.now(); pl.bookingId = null; pl.sessionGames = 0; } }
function kickPlayer(courtIdx, slotIdx) {
    const court = courts[courtIdx]; const pObj = court.players[slotIdx]; if(!pObj || !confirm(`‡πÄ‡∏õ‡∏•‡∏µ‡πà‡∏¢‡∏ô‡∏ï‡∏±‡∏ß ${pObj.name} ‡∏≠‡∏≠‡∏Å?`)) return;
    sendToQueue(pObj.id); court.players.splice(slotIdx, 1); court.autoStartTarget = null; renderCourts();
}

// --- UI HELPERS ---
function renderMatchLog() {
    const tbody = document.getElementById('match-log-body');
    if (matchLogs.length === 0) { tbody.innerHTML = '<tr><td colspan="5" style="color:gray;">-</td></tr>'; return; }
    tbody.innerHTML = matchLogs.map(log => `<tr><td>${log.time}</td><td>${log.court}</td><td class="log-winner">${log.winners}</td><td class="log-loser">${log.losers}</td><td>${log.duration}</td></tr>`).join('');
}

function updateDashboard() {
    const tbody = document.getElementById('stats-body');
    const sortType = document.getElementById('sort-select').value;
    
    let sorted = [...players].sort((a, b) => {
        if (sortType === 'games_desc') return b.gamesPlayed - a.gamesPlayed;
        if (sortType === 'games_asc') return a.gamesPlayed - b.gamesPlayed;
        if (sortType === 'wins_desc') return b.wins - a.wins;
        return 0;
    });

    tbody.innerHTML = sorted.map((p, index) => {
        let rank = index + 1;
        let medal = '';
        if (rank === 1) medal = 'ü•á'; else if (rank === 2) medal = 'ü•à'; else if (rank === 3) medal = 'ü•â';
        const rate = p.gamesPlayed > 0 ? Math.round((p.wins / p.gamesPlayed) * 100) : 0;
        return `<tr><td>${medal} ${rank}</td><td>${p.name}</td><td>${p.gamesPlayed}</td><td>${p.wins}</td><td>${rate}%</td></tr>`;
    }).join('');
}

// --- OVERVIEW & COST ---
function renderOverview() {
    const statsBody = document.getElementById('overview-stats-body');
    const repeatBody = document.getElementById('overview-repeat-body');
    
    statsBody.innerHTML = players.map(p => {
        let time = p.checkInTime ? new Date(p.checkInTime).toLocaleTimeString('th-TH', {hour:'2-digit', minute:'2-digit'}) : '-';
        return `<tr><td style="text-align:left">${p.name}</td><td>${time}</td><td>${p.gamesPlayed}</td><td>${p.wins}</td></tr>`;
    }).join('');

    let repeats = [];
    for (const [key, count] of Object.entries(pairingHistory)) {
        if (count > 1) {
            const [id1, id2] = key.split('-');
            const p1 = players.find(p => p.id == id1); const p2 = players.find(p => p.id == id2);
            if (p1 && p2) repeats.push({ name: `${p1.name} + ${p2.name}`, count: count });
        }
    }
    repeats.sort((a, b) => b.count - a.count);
    repeatBody.innerHTML = repeats.length === 0 ? '<tr><td colspan="2" style="color:green;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà‡∏ã‡πâ‡∏≥</td></tr>' : repeats.map(s => `<tr><td style="text-align:left;">${s.name}</td><td style="color:#e65100; font-weight:bold;">${s.count}</td></tr>`).join('');

    updateCost();
}

let isCustomHours = false;
function toggleCustomHours() {
    isCustomHours = !isCustomHours;
    document.getElementById('custom-hours-area').style.display = isCustomHours ? 'block' : 'none';
    document.getElementById('std-hours-group').style.display = isCustomHours ? 'none' : 'flex';
    updateCustomHoursInputs();
    updateCost();
}

function updateCustomHoursInputs() {
    const area = document.getElementById('custom-hours-area');
    area.innerHTML = '';
    for(let i=0; i<courtCount; i++) {
        area.innerHTML += `<div style="display:flex; justify-content:space-between; margin-bottom:5px;"><label>‡∏Ñ‡∏≠‡∏£‡πå‡∏ó ${i+1}:</label><input type="number" class="court-hr-input" value="2" style="width:50px;" onchange="updateCost()"> ‡∏ä‡∏°.</div>`;
    }
}

// ==========================================
// üí∞ LOGIC ‡∏´‡∏≤‡∏£‡∏Ñ‡πà‡∏≤‡∏™‡∏ô‡∏≤‡∏°‡πÅ‡∏ö‡∏ö‡πÅ‡∏ü‡∏£‡πå‡πÜ (Time-based)
// ==========================================

function updateCost() {
    // 1. ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏° (Grand Total) ‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°‡πÄ‡∏õ‡πä‡∏∞
    const pricePerHr = parseFloat(document.getElementById('calc-court-price').value) || 0;
    let totalHours = 0;

    if (isCustomHours) {
        document.querySelectorAll('.court-hr-input').forEach(inp => totalHours += parseFloat(inp.value) || 0);
    } else {
        totalHours = (parseFloat(document.getElementById('calc-hours').value) || 0) * (parseFloat(document.getElementById('calc-court-count').value) || 0);
    }

    const shuttlePrice = parseFloat(document.getElementById('calc-shuttle-price').value) || 0;
    const shuttleUsed = parseFloat(document.getElementById('calc-shuttle-used').value) || 0;
    const shuttleTotal = (shuttlePrice / 12) * shuttleUsed;

    const grandTotal = (totalHours * pricePerHr) + shuttleTotal;
    
    // ‡πÅ‡∏™‡∏î‡∏á‡∏¢‡∏≠‡∏î‡∏£‡∏ß‡∏°‡∏ó‡∏µ‡πà‡∏´‡∏ô‡πâ‡∏≤‡∏à‡∏≠
    document.getElementById('total-cost-display').innerText = grandTotal.toLocaleString(undefined, {minimumFractionDigits: 0, maximumFractionDigits: 0});

    // 2. --- ‡∏™‡πà‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡πÄ‡∏û‡∏¥‡πà‡∏°: ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏Ñ‡πà‡∏≤‡πÉ‡∏ä‡πâ‡∏à‡πà‡∏≤‡∏¢‡∏£‡∏≤‡∏¢‡∏Ñ‡∏ô ---
    const now = new Date();
    let totalMinutesAllPlayers = 0;

    // ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà 1: ‡∏ô‡∏±‡∏ö‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏ß‡∏°‡∏Ç‡∏≠‡∏á‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ô (‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏ô‡∏≤‡∏ó‡∏µ)
    players.forEach(p => {
        if (p.checkInTime) {
            // ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏±‡πâ‡∏á‡πÅ‡∏ï‡πà Check-in ‡∏à‡∏ô‡∏ñ‡∏∂‡∏á‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô (‡∏´‡∏ô‡πà‡∏ß‡∏¢‡∏ô‡∏≤‡∏ó‡∏µ)
            const diffMs = now - new Date(p.checkInTime);
            p.minutesPresent = Math.max(1, Math.floor(diffMs / 60000)); // ‡∏≠‡∏¢‡∏π‡πà‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 1 ‡∏ô‡∏≤‡∏ó‡∏µ
        } else {
            p.minutesPresent = 0; 
        }
        totalMinutesAllPlayers += p.minutesPresent;
    });

    // ‡∏£‡∏≠‡∏ö‡∏ó‡∏µ‡πà 2: ‡πÄ‡∏ó‡∏µ‡∏¢‡∏ö‡∏ö‡∏±‡∏ç‡∏ç‡∏±‡∏ï‡∏¥‡πÑ‡∏ï‡∏£‡∏¢‡∏≤‡∏á‡∏®‡πå (‡πÄ‡∏ß‡∏•‡∏≤‡∏Ç‡∏≠‡∏á‡∏Å‡∏π / ‡πÄ‡∏ß‡∏•‡∏≤‡∏£‡∏ß‡∏°‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î) * ‡∏¢‡∏≠‡∏î‡πÄ‡∏á‡∏¥‡∏ô‡∏£‡∏ß‡∏°
    players.forEach(p => {
        if (totalMinutesAllPlayers > 0 && grandTotal > 0) {
            p.calculatedCost = (p.minutesPresent / totalMinutesAllPlayers) * grandTotal;
        } else {
            p.calculatedCost = 0;
        }
    });

    // 3. ‡∏™‡∏±‡πà‡∏á‡∏ß‡∏≤‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡πÉ‡∏´‡∏°‡πà‡∏ó‡∏±‡∏ô‡∏ó‡∏µ ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÇ‡∏ä‡∏ß‡πå‡∏ï‡∏±‡∏ß‡πÄ‡∏•‡∏Ç (‡∏™‡πà‡∏á true ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ö‡∏≠‡∏Å‡∏ß‡πà‡∏≤‡πÑ‡∏°‡πà‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏£‡∏µ‡∏¢‡∏Å updateCost ‡∏ã‡πâ‡∏≥)
    renderOverview(true); 
}

function renderOverview(skipUpdateCost = false) {
    const statsBody = document.getElementById('overview-stats-body');
    const repeatBody = document.getElementById('overview-repeat-body');
    
    // ‡∏ß‡∏≤‡∏î‡∏ï‡∏≤‡∏£‡∏≤‡∏á‡∏£‡∏≤‡∏¢‡∏ä‡∏∑‡πà‡∏≠ + ‡∏£‡∏≤‡∏Ñ‡∏≤‡∏ó‡∏µ‡πà‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡πÅ‡∏•‡πâ‡∏ß
    statsBody.innerHTML = players.map(p => {
        let time = p.checkInTime ? new Date(p.checkInTime).toLocaleTimeString('th-TH', {hour:'2-digit', minute:'2-digit'}) : '-';
        // ‡∏õ‡∏±‡∏î‡πÄ‡∏®‡∏©‡πÄ‡∏á‡∏¥‡∏ô‡πÉ‡∏´‡πâ‡∏™‡∏ß‡∏¢‡πÜ (Ceil = ‡∏õ‡∏±‡∏î‡∏Ç‡∏∂‡πâ‡∏ô‡πÉ‡∏´‡πâ‡πÄ‡∏®‡∏©‡∏™‡∏ï‡∏≤‡∏á‡∏Ñ‡πå‡πÑ‡∏°‡πà‡∏´‡∏≤‡∏¢)
        let costShow = p.calculatedCost ? Math.ceil(p.calculatedCost) : 0; 
        
        return `
            <tr>
                <td style="text-align:left">
                    ${p.name} 
                    <div style="font-size:0.75em; color:gray;">(‡∏≠‡∏¢‡∏π‡πà‡∏°‡∏≤ ${p.minutesPresent || 0} ‡∏ô.)</div>
                </td>
                <td>${time}</td>
                <td>${p.gamesPlayed}</td>
                <td>${p.wins}</td>
                <td style="font-weight:bold; color:#27ae60;">${costShow} ‡∏ø</td>
            </tr>`;
    }).join('');

    // ‡∏™‡πà‡∏ß‡∏ô‡∏Ñ‡∏π‡πà‡∏ã‡πâ‡∏≥ (‡πÄ‡∏´‡∏°‡∏∑‡∏≠‡∏ô‡πÄ‡∏î‡∏¥‡∏°)
    let repeats = [];
    for (const [key, count] of Object.entries(pairingHistory)) {
        if (count > 1) {
            const [id1, id2] = key.split('-');
            const p1 = players.find(p => p.id == id1); const p2 = players.find(p => p.id == id2);
            if (p1 && p2) repeats.push({ name: `${p1.name} + ${p2.name}`, count: count });
        }
    }
    repeats.sort((a, b) => b.count - a.count);
    repeatBody.innerHTML = repeats.length === 0 ? '<tr><td colspan="2" style="color:green;">‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏Ñ‡∏π‡πà‡∏ã‡πâ‡∏≥</td></tr>' : repeats.map(s => `<tr><td style="text-align:left;">${s.name}</td><td style="color:#e65100; font-weight:bold;">${s.count}</td></tr>`).join('');

    // ‡πÄ‡∏£‡∏µ‡∏¢‡∏Å updateCost ‡πÄ‡∏â‡∏û‡∏≤‡∏∞‡∏ï‡∏≠‡∏ô‡∏ó‡∏µ‡πà‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏ñ‡∏π‡∏Å‡πÄ‡∏£‡∏µ‡∏¢‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å updateCost (‡∏Å‡∏±‡∏ô Loop ‡∏ô‡∏£‡∏Å)
    if (!skipUpdateCost) updateCost();
}

function endSession() {
    const element = document.getElementById("summary-capture-area");
    html2canvas(element).then(canvas => {
        const link = document.createElement('a');
        link.download = 'badminton-summary.png';
        link.href = canvas.toDataURL();
        link.click();
    });
}

// Modal & Queue
let currentBookingType = '';
function openBookingModal(type) { 
    currentBookingType = type; 
    const waiting = players.filter(p => p.status === 'waiting' && !p.bookingId);
    let html = '';
    if (waiting.length < (type === 'pair' ? 2 : 4)) html = '<p style="color:red">‡∏Ñ‡∏ô‡∏ß‡πà‡∏≤‡∏á‡πÑ‡∏°‡πà‡∏û‡∏≠!</p>';
    else { html = `<p>‡πÄ‡∏•‡∏∑‡∏≠‡∏Å ${type === 'pair' ? 2 : 4} ‡∏Ñ‡∏ô:</p>`; waiting.forEach(p => { html += `<div><input type="checkbox" name="book-p" value="${p.id}"> ${p.name}</div>`; }); }
    document.getElementById('booking-inputs').innerHTML = html; document.getElementById('booking-modal').style.display = 'flex'; 
}
function confirmBooking() {
    const cbs = document.querySelectorAll('input[name="book-p"]:checked');
    if (cbs.length !== (currentBookingType === 'pair' ? 2 : 4)) { alert('‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏Ñ‡∏ô‡πÑ‡∏°‡πà‡∏Ñ‡∏£‡∏ö'); return; }
    const bId = 'book-' + (++bookingCounter); cbs.forEach(cb => { const p = players.find(x => x.id == cb.value); if(p) p.bookingId = bId; });
    closeModal('booking-modal'); updateQueueDisplay();
}
function updateQueueDisplay() {
    const list = document.getElementById('player-queue');
    const waiting = players.filter(p => p.status === 'waiting');
    waiting.sort((a, b) => a.joinedQueueAt - b.joinedQueueAt);
    document.getElementById('queue-count').innerText = waiting.length;
    list.innerHTML = waiting.map(p => {
        let badgeClass = 'wait-green'; let badgeText = '<5m';
        const min = (players.indexOf(p) + 1) * (AVG_GAME_DURATION / (courtCount * 2));
        if (min > 10) { badgeClass = 'wait-red'; badgeText = '>10m'; } else if (min >= 5) { badgeClass = 'wait-orange'; badgeText = '5-10m'; }
        return `<li class="player-item ${p.bookingId ? 'booked' : ''} ${p.isFastPass ? 'fastpass' : ''}"><div class="player-info"><strong>${p.isFastPass?'üöÄ ':''}${p.name}</strong>${p.bookingId?'<small>üîí</small>':''}<span class="wait-badge ${badgeClass}">${badgeText}</span></div><button class="mini-btn danger" onclick="removePlayer(${p.id})">√ó</button></li>`;
    }).join('');
}
function formatTime(s) { return `${Math.floor(s/60).toString().padStart(2,'0')}:${(s%60).toString().padStart(2,'0')}`; }
function closeModal(id) { document.getElementById(id).style.display = 'none'; }

init();
</script>